<!doctype html>
<html lang="vi">
<!-- Chuyển đổi từ PPTX: lec11 - Recursion.pptx
     Theo định dạng tham chiếu: lecture-10-classes-methods-subclasses.html -->

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Bài 11: Đệ quy (Recursion)</title>

  <link rel="stylesheet" href="revealjs/dist/reset.css" />
  <link rel="stylesheet" href="revealjs/dist/reveal.css" />
  <link rel="stylesheet" href="revealjs/dist/theme/white.css" />
  <link rel="stylesheet" href="plugin/highlight/monokai.css" />
  <link rel="stylesheet" href="lecture-style.css" />
</head>

<body>
  <div class="reveal">
    <div class="slides">

      <!-- ====================== Slide: Trang tiêu đề ====================== -->
      <section>
        <section>
          <h2 class="r-fit-text">Tư duy Tính toán</h2>
          <h2>Đệ quy (Recursion)</h2>
          <p>Trường ĐH Công nghệ – Đại học Quốc gia Hà Nội</p>
        </section>

        <!-- ====================== Slide: Nội dung ====================== -->
        <section>
          <h2>Nội dung</h2>
          <ol>
            <li>Đệ quy: lặp lại <span class="keyword">không cần</span> vòng lặp <span class="inline-code">for</span>
            </li>
            <li>Hàm số học lặp &amp; đệ quy (giai thừa, tổng)</li>
            <li>Trường hợp cơ sở, trường hợp đệ quy &amp; đệ quy vô hạn</li>
            <li>Đệ quy với nhiều trường hợp cơ sở: Fibonacci</li>
            <li>Đệ quy trên dữ liệu lồng nhau</li>
            <li>So sánh đệ quy &amp; vòng lặp; mẫu lập trình đệ quy</li>
          </ol>
          <p><strong>Tài liệu đọc:</strong> <em>Think Python 3rd ed.</em>, 5.{8–10}, 6.{6–8}</p>
        </section>
      </section>

      <!-- ====================== Chương 1: Đệ quy – lặp lại không cần for ====================== -->
      <section>
        <!-- ====================== Slide: Tiêu đề chương ====================== -->
        <section>
          <h1>
            <span class="text-light">1.</span><br />
            Đệ quy: lặp lại <br />không cần vòng lặp
          </h1>
        </section>

        <!-- ====================== Slide: Repetition Without Loops ====================== -->
        <section>
          <h2>Lặp lại mà không cần vòng lặp</h2>
          <ul>
            <li>Chúng ta đã dùng <span class="inline-code">for</span> để lặp lại một khối lệnh.</li>
            <li>Nhưng có thể lặp lại <span class="keyword">không dùng</span> vòng lặp!</li>
            <li>Ý tưởng: hàm có thể gọi <span class="keyword">chính nó</span> như hàm trợ giúp.</li>
            <li>Đó là <span class="keyword">đệ quy</span> (recursion).</li>
          </ul>
        </section>

        <!-- ====================== Slide: Countdown with loop ====================== -->
        <section data-auto-animate>
          <h2>Đếm ngược bằng vòng lặp <span class="inline-code">for</span></h2>
          <pre><code class="language-python" data-trim data-line-numbers="">
def blast_off_loop(n):
    """Print a countdown starting at n.
       n: a non-negative int"""
    for n in range(n, 0, -1):
        print(n)
    print('BLAST OFF!')
          </code></pre>
          <ul>
            <li>Dùng <span class="inline-code">range(n, 0, -1)</span> để đi từ <span class="inline-code">n</span> xuống
              <span class="inline-code">1</span>.
            </li>
            <li>Đây là cách làm <span class="keyword">lặp (iterative)</span> quen thuộc.</li>
          </ul>
        </section>

        <!-- ====================== Slide: range step ====================== -->
        <section data-auto-animate>
          <h2>Thuộc tính <span class="inline-code">step</span> của <span class="inline-code">range</span></h2>
          <pre><code class="language-pycon" data-trim>
>>> r3 = range(3)
>>> r3.step
1
>>> r10 = range(0, 10, 2)
>>> r10.step
2
>>> list(r10)
[0, 2, 4, 6, 8]
>>> r_down = range(10, 0, -1)
>>> list(r_down)
[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
          </code></pre>
          <p><span class="keyword">step</span> cho biết “bước nhảy” giữa hai giá trị liên tiếp trong
            <span class="inline-code">range</span>.
          </p>
        </section>

        <!-- ====================== Slide: Countdown without loop (recursive) ====================== -->
        <section data-auto-animate>
          <h2>Đếm ngược mà <em>không</em> dùng vòng lặp</h2>
          <pre><code class="language-python" data-trim data-line-numbers="">
def blast_off_no_loop(n):
    """Print a countdown starting at n.
       n: a non-negative int"""
    if n == 0:
        print('BLAST OFF!')
    else:
        print(n)
        blast_off_no_loop(n-1)
          </code></pre>
          <ul>
            <li>Nếu <span class="inline-code">n == 0</span> &rarr; in <span class="inline-code">'BLAST
                OFF!'</span>
              (<span class="keyword">trường hợp cơ sở</span>).</li>
            <li>Ngược lại: in <span class="inline-code">n</span> rồi gọi lại hàm với <span
                class="inline-code">n-1</span>
              (<span class="keyword">trường hợp đệ quy</span>).</li>
          </ul>
        </section>

        <!-- ====================== Slide: Recursive calls ====================== -->
        <section>
          <h2>Hàm gọi chính nó</h2>
          <ul>
            <li>Một hàm có thể gọi các hàm trợ giúp khác.</li>
            <li>Nó cũng có thể gọi <span class="keyword">chính nó</span> &rarr; gọi đó là
              <span class="keyword">lời gọi đệ quy</span>.
            </li>
            <li>Hàm chứa ít nhất một lời gọi đệ quy là một <span class="keyword">hàm đệ quy</span>.</li>
            <li>Thực thi hàm đệ quy không hề “ma thuật”: ta hiểu được bằng <span class="keyword">call
                stack</span> và
              sơ đồ gọi hàm.</li>
          </ul>
        </section>

        <!-- ====================== Slide: Recursion vs iteration (intro) ====================== -->
        <section>
          <h2>Đệ quy vs. lặp</h2>
          <ul>
            <li><span class="keyword">Đệ quy</span>: dùng hàm đệ quy để lặp lại công việc.</li>
            <li><span class="keyword">Lặp (iteration)</span>: dùng vòng lặp <span class="inline-code">for</span> hoặc
              <span class="inline-code">while</span>.
            </li>
            <li>Cả hai đều là mẫu lập trình cho <span class="keyword">sự lặp lại</span>.</li>
            <li>Đệ quy (với <span class="inline-code">while</span>) mạnh không kém gì vòng lặp, đôi khi còn
              thuận
              tiện hơn.</li>
          </ul>
        </section>
      </section>

      <!-- ====================== Chương 2: Hàm số học lặp & đệ quy ====================== -->
      <section>
        <!-- ====================== Slide: Tiêu đề chương ====================== -->
        <section>
          <h1>
            <span class="text-light">2.</span><br />
            Hàm số học lặp &amp; đệ quy
          </h1>
        </section>

        <!-- ====================== Slide: Factorial motivation ====================== -->
        <section>
          <h2>Phép hoán vị &amp; giai thừa</h2>
          <ul>
            <li>Có bao nhiêu cách sắp xếp <span class="keyword">n</span> phần tử phân biệt?</li>
            <li><span class="inline-code">n = 2</span>:
              <ul>
                <li>A, B</li>
                <li>B, A</li>
                <li>&rarr; Có <span class="inline-code">2 = 2 * 1</span> cách.</li>
              </ul>
            </li>
            <li><span class="inline-code">n = 3</span>: 6 cách sắp, <span class="inline-code">= 3 * 2 *
                1</span>.</li>
            <li>Nhìn chung: <span class="keyword">n!</span> là số hoán vị của <span class="inline-code">n</span> phần
              tử.
            </li>
          </ul>
        </section>

        <!-- ====================== Slide: Factorial definition ====================== -->
        <section data-auto-animate>
          <h2>Toán tử / hàm giai thừa</h2>
          <ul>
            <li><span class="inline-code">n! = n * (n - 1) * ... * 2 * 1</span></li>
            <li>Hoặc: <span class="inline-code">n! = 1 * 2 * ... * (n - 1) * n</span></li>
            <li>Hoặc đệ quy:
              <ul>
                <li><span class="inline-code">n! = n * (n - 1)!</span></li>
                <li><span class="inline-code">0! = 1</span> (quy ước cơ sở).</li>
              </ul>
            </li>
          </ul>
        </section>

        <!-- ====================== Slide: Iterative factorial ====================== -->
        <section data-auto-animate>
          <h2>Giai thừa dạng lặp (iterative)</h2>
          <pre><code class="language-python" data-trim data-line-numbers="">
def factorial_iter(n):
    """Returns n!.
    n: a non-negative integer"""
    product = 1
    for i in range(1, n+1):  # 1..n
        product = product * i
    return product
          </code></pre>
          <p>Dùng biến tạm <span class="inline-code">product</span> để tích lũy kết quả trong vòng
            <span class="inline-code">for</span>.
          </p>
        </section>

        <!-- ====================== Slide: Recursive factorial ====================== -->
        <section data-auto-animate>
          <h2>Giai thừa dạng đệ quy</h2>
          <pre><code class="language-python" data-trim data-line-numbers="">
def factorial_rec(n):
    """Returns n!.
    n: a non-negative integer"""
    if n == 0:
        return 1
    else:
        n_minus_1_fact = factorial_rec(n-1)
        return n * n_minus_1_fact
          </code></pre>
          <ul>
            <li>Trường hợp cơ sở: <span class="inline-code">n == 0</span> &rarr; trả về <span
                class="inline-code">1</span>.
            </li>
            <li>Trường hợp đệ quy: cần <span class="inline-code">(n-1)!</span> để nhân với <span
                class="inline-code">n</span>.
            </li>
          </ul>
        </section>

        <!-- ====================== Slide: Analogy for call frames ====================== -->
        <section>
          <h2>Tưởng tượng các khung gọi hàm (call frame)</h2>
          <ul>
            <li>Mỗi lần gọi hàm tạo một <span class="keyword">khung</span> mới trên call stack.</li>
            <li>Với <span class="inline-code">factorial_rec(4)</span>, ta có các khung cho:
              <span class="inline-code">n = 4, 3, 2, 1, 0</span>.
            </li>
            <li>Khi quay lui (return), kết quả được “trả ngược” lên các khung trước.</li>
            <li>Hình dung call stack giúp hiểu rõ cách đệ quy thực thi.</li>
          </ul>
        </section>

        <!-- ====================== Slide: Quiz mystery ====================== -->
        <section>
          <h2>Ví dụ &amp; Quiz: hàm <span class="inline-code">mystery</span></h2>
          <pre><code class="language-python" data-trim data-line-numbers="">
def mystery(n):
    if n == 0:
        return 0
    else:
        n_minus_1_result = mystery(n-1)
        return n + n_minus_1_result

print(mystery(4))
          </code></pre>
          <p><strong>Câu hỏi:</strong> Hàm này in ra gì?</p>
          <ul>
            <li>A: 0 &nbsp;&nbsp; B: 1 &nbsp;&nbsp; C: 4 &nbsp;&nbsp; D: 7 &nbsp;&nbsp; E: 10
            </li>
          </ul>
        </section>

        <!-- ====================== Slide: Vocabulary for recursive defs (code) ====================== -->
        <section data-auto-animate>
          <h2>Từ vựng cho đệ quy</h2>
          <pre><code class="language-python" data-trim data-line-numbers="">
def factorial_rec(n):
    """Returns n!.
    n: a non-negative integer"""
    if n == 0:
        return 1
    else:
        n_minus_1_fact = factorial_rec(n-1)
        return n * n_minus_1_fact
          </code></pre>
          <ul>
            <li><span class="keyword">Base case</span>: <span class="inline-code">n == 0</span> &rarr; trả
              về 1.</li>
            <li><span class="keyword">Recursive case</span>: <span class="inline-code">n &gt; 0</span>
              &rarr; cần
              <span class="inline-code">factorial_rec(n-1)</span>.
            </li>
          </ul>
        </section>

        <!-- ====================== Slide: Vocabulary base vs recursive ====================== -->
        <section data-auto-animate>
          <h2>Base case vs. Recursive case</h2>
          <ul>
            <li><span class="keyword">Base case</span>:
              <ul>
                <li>Không gọi đệ quy.</li>
                <li>Tự tính được đáp án <span class="keyword">ngay lập tức</span>.</li>
              </ul>
            </li>
            <li><span class="keyword">Recursive case</span>:
              <ul>
                <li>Có ít nhất một lời gọi đệ quy.</li>
                <li>Cần “nhờ chính mình” giải bài toán nhỏ hơn rồi kết hợp lại.</li>
              </ul>
            </li>
          </ul>
        </section>
      </section>

      <!-- ====================== Chương 3: Đệ quy vô hạn & RecursionError ====================== -->
      <section>
        <!-- ====================== Slide: Tiêu đề chương ====================== -->
        <section>
          <h1>
            <span class="text-light">3.</span><br />
            Đệ quy vô hạn &amp; <br />lỗi <span class="inline-code">RecursionError</span>
          </h1>
        </section>

        <!-- ====================== Slide: Defined in terms of itself ====================== -->
        <section data-auto-animate>
          <h2>Định nghĩa một thứ bằng chính nó?</h2>
          <pre><code class="language-python" data-trim data-line-numbers="">
def factorial_rec(n):
    """Returns n!.
    n: a non-negative integer"""
    if n == 0:
        return 1
    else:
        n_minus_1_fact = factorial_rec(n-1)
        return n * n_minus_1_fact
          </code></pre>
          <p>Về toán học:</p>
          <ul>
            <li><span class="inline-code">n! = n * (n - 1)!</span> &nbsp; (trường hợp đệ quy)</li>
            <li><span class="inline-code">0! = 1</span> &nbsp; (trường hợp cơ sở)</li>
          </ul>
        </section>

        <!-- ====================== Slide: But is it circular? ====================== -->
        <section data-auto-animate>
          <h2>Có vô lý không?</h2>
          <ul>
            <li>Câu hỏi: “Định nghĩa một thứ bằng chính nó” có phải là <span class="keyword">vòng
                tròn</span>?
            </li>
            <li>Trả lời:
              <ul>
                <li>Nếu <span class="keyword">có base case</span> &amp; mỗi bước tiến tới đó &rarr; OK.
                </li>
                <li>Nếu không cẩn thận &rarr; dẫn đến <span class="keyword">đệ quy vô hạn</span>.</li>
              </ul>
            </li>
          </ul>
        </section>

        <!-- ====================== Slide: Infinite recursion simple ====================== -->
        <section data-auto-animate>
          <h2>Đệ quy vô hạn (ví dụ 1)</h2>
          <pre><code class="language-python" data-trim data-line-numbers="">
# recursionerrors.py
def infinite_recursion():
    infinite_recursion()
          </code></pre>
          <pre><code class="language-pycon" data-trim>
>>> import recursionerrors
>>> recursionerrors.infinite_recursion()
... RecursionError: maximum recursion depth exceeded
          </code></pre>
          <p>Không có base case &rarr; hàm tự gọi <span class="keyword">mãi mãi</span> (cho tới khi Python
            chặn lại).</p>
        </section>

        <!-- ====================== Slide: Infinite recursion buggy countdown ====================== -->
        <section data-auto-animate>
          <h2>Đệ quy vô hạn (ví dụ 2)</h2>
          <pre><code class="language-python" data-trim data-line-numbers="">
# recursionerrors.py
def bad_blast_off_v1(n):
    if n == 0:
        print('BLAST OFF!')
    else:
        print(n)
        bad_blast_off_v1(n)  # BUG: need "n-1"


def bad_blast_off_v2(n):
    # BUG: no base case
    print(n)
    bad_blast_off_v2(n-1)
          </code></pre>
          <ul>
            <li><span class="inline-code">bad_blast_off_v1</span>: quên giảm <span class="inline-code">n</span>.</li>
            <li><span class="inline-code">bad_blast_off_v2</span>: không có base case.</li>
            <li>Cả hai đều dẫn tới <span class="keyword">RecursionError</span>.</li>
          </ul>
        </section>

        <!-- ====================== Slide: Python prevents infinite recursion ====================== -->
        <section>
          <h2>Python ngăn đệ quy vô hạn</h2>
          <ul>
            <li>Số lượng khung gọi hàm trên stack là <span class="keyword">hữu hạn</span> (mặc định ~1000).
            </li>
            <li>Nếu chương trình bị “kẹt” trong đệ quy, Python sẽ dừng với lỗi
              <span class="inline-code">RecursionError</span>.
            </li>
            <li>Nhờ đó ta không thực sự chạy mã <span class="keyword">vô hạn</span>, chỉ gặp lỗi báo sớm.
            </li>
            <li>Thông điệp: hãy luôn kiểm tra:
              <ul>
                <li>Có <span class="keyword">base case</span> hay không?</li>
                <li>Có đảm bảo mỗi bước tiến tới base case không?</li>
              </ul>
            </li>
          </ul>
        </section>

        <!-- ====================== Slide: Quiz RecursionError ====================== -->
        <section>
          <h2>Quiz: trường hợp nào gây <span class="inline-code">RecursionError</span>?</h2>
          <pre><code class="language-python" data-trim data-line-numbers="">
# A
def recurse(n):
    if n == 0:
        return
    recurse(n-1)
          </code></pre>
          <pre><code class="language-python" data-trim data-line-numbers="">
# B
def recurse(n):
    if n == 0:
        return
    recurse(n+1)
          </code></pre>
          <p>Tiền điều kiện chung: <span class="inline-code">n &gt;= 0</span>.</p>
          <ul>
            <li>A: Chỉ A &nbsp;&nbsp; B: Chỉ B &nbsp;&nbsp; C: Cả hai</li>
          </ul>
        </section>
      </section>

      <!-- ====================== Chương 4: Đệ quy với nhiều base case – Fibonacci ====================== -->
      <section>
        <!-- ====================== Slide: Tiêu đề chương ====================== -->
        <section>
          <h1>
            <span class="text-light">4.</span><br />
            Đệ quy với nhiều<br />base case: Fibonacci
          </h1>
        </section>

        <!-- ====================== Slide: Fibonacci sequence ====================== -->
        <section data-auto-animate>
          <h2>Dãy Fibonacci</h2>
          <p>Chuỗi số:</p>
          <p><span class="inline-code">0, 1, 1, 2, 3, 5, 8, 13, 21, 34, …</span></p>
          <ul>
            <li>Mỗi số (từ vị trí thứ 2) bằng tổng của <span class="keyword">hai số trước</span>.</li>
            <li>Ứng dụng:
              <ul>
                <li>Thơ ca (mẫu thơ Sanskrit)</li>
                <li>Sinh học: phân nhánh cây</li>
                <li>Sinh thái: mô hình tăng trưởng dân số</li>
                <li>… và rất nhiều lĩnh vực khác</li>
              </ul>
            </li>
          </ul>
        </section>

        <!-- ====================== Slide: Fibonacci recursive definition ====================== -->
        <section data-auto-animate>
          <h2>Định nghĩa đệ quy của Fibonacci</h2>
          <ul>
            <li><span class="inline-code">F(0) = 0</span> &nbsp; (base case)</li>
            <li><span class="inline-code">F(1) = 1</span> &nbsp; (base case)</li>
            <li><span class="inline-code">F(n) = F(n - 1) + F(n - 2)</span> &nbsp; (recursive case)</li>
          </ul>
          <p>Có <span class="keyword">hai</span> base case &mdash; rất phổ biến trong đệ quy.</p>
        </section>

        <!-- ====================== Slide: Recursive Fibonacci ====================== -->
        <section data-auto-animate>
          <h2>Fibonacci đệ quy</h2>
          <pre><code class="language-python" data-trim data-line-numbers="">
def fibo_rec(n):
    """Returns  F(n).
    n: a non-negative integer"""
    if n == 0 or n == 1:
        return n
    else:
        return fibo_rec(n-1) + fibo_rec(n-2)
          </code></pre>
          <ul>
            <li>Rất gần với định nghĩa toán học.</li>
            <li>Mã ngắn gọn, dễ đọc &rarr; <span class="keyword">dễ cài đặt</span>.</li>
          </ul>
        </section>

        <section data-auto-animate>
          <h2>Fibonacci đệ quy</h2>
          <p>
            <span class="inline-code">fibo_rec(n)</span> tạo ra rất nhiều
            <span class="keyword">lời gọi lặp lại</span>.
          </p>

          <svg height="360" viewBox="0 0 900 360" xmlns="http://www.w3.org/2000/svg" role="img"
            aria-label="Cây lời gọi fib(5) minh họa các lời gọi lặp lại">
            <style>
              .fib-node {
                fill: #c7f1b3;
                stroke: #3a7c29;
                stroke-width: 1;
                rx: 6;
                ry: 6;
              }

              .fib-text {
                font-family: "DejaVu Sans", "Segoe UI", sans-serif;
                font-size: 13px;
                fill: #000;
              }

              .fib-text-repeat {
                fill: #0057d9;
                font-weight: 700;
              }

              .fib-arrow {
                stroke: #333;
                stroke-width: 1.1;
                marker-end: url(#arrowhead);
              }
            </style>

            <!-- Mũi tên -->
            <defs>
              <marker id="arrowhead" markerWidth="8" markerHeight="6" refX="6" refY="3" orient="auto">
                <polygon points="0 0, 8 3, 0 6" fill="#333" />
              </marker>
            </defs>

            <!-- Hàng 0: fib(5) -->
            <rect class="fib-node" x="410" y="20" width="80" height="30" />
            <text class="fib-text" x="450" y="40" text-anchor="middle">fib(5)</text>

            <!-- Hàng 1: fib(4), fib(3) -->
            <rect class="fib-node" x="260" y="90" width="80" height="30" />
            <text class="fib-text" x="300" y="110" text-anchor="middle">fib(4)</text>

            <rect class="fib-node" x="560" y="90" width="80" height="30" />
            <text class="fib-text" x="600" y="110" text-anchor="middle">fib(3)</text>

            <!-- Cạnh từ fib(5) -->
            <line class="fib-arrow" x1="450" y1="50" x2="300" y2="90" />
            <line class="fib-arrow" x1="450" y1="50" x2="600" y2="90" />

            <!-- Hàng 2 trái: fib(3) từ fib(4), fib(2) từ fib(4) -->
            <rect class="fib-node" x="180" y="160" width="80" height="30" />
            <text class="fib-text" x="220" y="180" text-anchor="middle">fib(3)</text>

            <rect class="fib-node" x="340" y="160" width="80" height="30" />
            <text class="fib-text" x="380" y="180" text-anchor="middle">fib(2)</text>

            <!-- Cạnh từ fib(4) -->
            <line class="fib-arrow" x1="300" y1="120" x2="220" y2="160" />
            <line class="fib-arrow" x1="300" y1="120" x2="380" y2="160" />

            <!-- Hàng 2 phải: fib(2) từ fib(3), fib(1) từ fib(3) -->
            <rect class="fib-node" x="500" y="160" width="80" height="30" />
            <text class="fib-text" x="540" y="180" text-anchor="middle">fib(2)</text>

            <rect class="fib-node" x="660" y="160" width="80" height="30" />
            <text class="fib-text fib-text-repeat" x="700" y="180" text-anchor="middle">
              fib(1)
            </text>

            <!-- Cạnh từ fib(3) bên phải -->
            <line class="fib-arrow" x1="600" y1="120" x2="540" y2="160" />
            <line class="fib-arrow" x1="600" y1="120" x2="700" y2="160" />

            <!-- Hàng 3 từ fib(3) bên trái: fib(2), fib(1) -->
            <rect class="fib-node" x="120" y="230" width="80" height="30" />
            <text class="fib-text" x="160" y="250" text-anchor="middle">fib(2)</text>

            <rect class="fib-node" x="240" y="230" width="80" height="30" />
            <text class="fib-text fib-text-repeat" x="280" y="250" text-anchor="middle">
              fib(1)
            </text>

            <!-- Cạnh từ fib(3) (bên dưới fib(4)) -->
            <line class="fib-arrow" x1="220" y1="190" x2="160" y2="230" />
            <line class="fib-arrow" x1="220" y1="190" x2="280" y2="230" />

            <!-- Lá của fib(2) (dưới fib(3) ở trái nhất): fib(1), fib(0) -->
            <rect class="fib-node" x="60" y="300" width="80" height="30" />
            <text class="fib-text fib-text-repeat" x="100" y="320" text-anchor="middle">
              fib(1)
            </text>

            <rect class="fib-node" x="180" y="300" width="80" height="30" />
            <text class="fib-text" x="220" y="320" text-anchor="middle">fib(0)</text>

            <line class="fib-arrow" x1="160" y1="260" x2="100" y2="300" />
            <line class="fib-arrow" x1="160" y1="260" x2="220" y2="300" />

            <!-- Lá của fib(2) (dưới fib(4) bên trái): fib(1), fib(0) -->
            <rect class="fib-node" x="320" y="230" width="80" height="30" />
            <text class="fib-text fib-text-repeat" x="360" y="250" text-anchor="middle">
              fib(1)
            </text>

            <rect class="fib-node" x="400" y="230" width="80" height="30" />
            <text class="fib-text" x="440" y="250" text-anchor="middle">fib(0)</text>

            <line class="fib-arrow" x1="380" y1="190" x2="360" y2="230" />
            <line class="fib-arrow" x1="380" y1="190" x2="440" y2="230" />
            <!-- Lá của fib(2) (dưới fib(3) bên phải): fib(1), fib(0) -->
            <rect class="fib-node" x="520" y="230" width="80" height="30" />
            <text class="fib-text fib-text-repeat" x="560" y="250" text-anchor="middle">
              fib(1)
            </text>

            <rect class="fib-node" x="640" y="230" width="80" height="30" />
            <text class="fib-text" x="680" y="250" text-anchor="middle">fib(0)</text>

            <line class="fib-arrow" x1="540" y1="190" x2="560" y2="230" />
            <line class="fib-arrow" x1="540" y1="190" x2="680" y2="230" />
          </svg>
        </section>


        <!-- ====================== Slide: Rec Fib frames vs calls 1 ====================== -->
        <section data-auto-animate>
          <h2>Fibonacci đệ quy</h2>
          <p>
            <span class="inline-code">fibo_rec(n)</span> tạo ra rất nhiều
            <span class="keyword">lời gọi lặp lại</span>.
          </p>

          <ul>
            <li>Ví dụ: <span class="inline-code">fibo_rec(5)</span> gọi:
              <ul>
                <li><span class="inline-code">fibo_rec(4)</span> và <span class="inline-code">fibo_rec(3)</span></li>
                <li>Trong đó <span class="inline-code">fibo_rec(4)</span> lại gọi <span
                    class="inline-code">fibo_rec(3)</span>
                  và <span class="inline-code">fibo_rec(2)</span>, v.v.</li>
              </ul>
            </li>
            <li>Nhiều tính toán bị <span class="keyword">lặp lại</span> &rarr; tốn thời gian.</li>
          </ul>
        </section>

        <!-- ====================== Slide: Rec Fib frames vs calls 2 ====================== -->
        <section data-auto-animate>
          <h2>Fibonacci đệ quy: trực quan về số frame</h2>
          <ul>
            <li>Biểu đồ cây lời gọi của <span class="inline-code">fibo_rec(n)</span> phình to rất nhanh.
            </li>
            <li>Số lượng khung gọi hàm (frame) tăng gần như <span class="keyword">theo cấp số nhân</span>.
            </li>
            <li>Vì vậy, dù dễ viết, hàm Fibonacci đệ quy này chạy <span class="keyword">không hiệu
                quả</span> cho
              <span class="inline-code">n</span> lớn.
            </li>
          </ul>
        </section>

        <!-- ====================== Slide: Iterative Fibonacci ====================== -->
        <section data-auto-animate>
          <h2>Fibonacci lặp (iterative)</h2>
          <pre><code class="language-python" data-trim data-line-numbers="">
def fibo_iter(n):
    if n == 0 or n == 1:
        return n
    else:
        a = 0
        b = 1
        for i in range(2, n+1):
            t = a
            a = b
            b = a + t
        return b
          </code></pre>
          <ul>
            <li>Cần suy nghĩ kỹ về:
              <ul>
                <li>giới hạn vòng lặp,</li>
                <li>ý nghĩa của các biến <span class="inline-code">a</span>, <span class="inline-code">b</span>, <span
                    class="inline-code">t</span>.
                </li>
              </ul>
            </li>
            <li>Đổi lại, giải pháp này <span class="keyword">không lặp lại tính toán</span>.</li>
          </ul>
        </section>

        <!-- ====================== Slide: Quiz Fibonacci iter ====================== -->
        <section style="font-size: 0.8em;">
          <h2>Quiz: <span class="inline-code">a</span>, <span class="inline-code">b</span> là gì?</h2>
          <pre><code class="language-python" data-trim data-line-numbers="">
def fibo_iter(n):
    if n == 0 or n == 1:
        return n
    else:
        a = 0
        b = 1
        for i in range(2, n+1):    # a = F(???), b = F(???)
            t = a
            a = b
            b = a + t
        return b
          </code></pre>
          <ul>
            <li>A: <span class="inline-code">a = F(i-2)</span>, <span class="inline-code">b = F(i-1)</span>
            </li>
            <li>B: <span class="inline-code">a = F(i-1)</span>, <span class="inline-code">b = F(i-2)</span>
            </li>
            <li>C: <span class="inline-code">a = F(i-1)</span>, <span class="inline-code">b = F(i-1)</span>
            </li>
            <li>D: <span class="inline-code">a = F(i-2), b = F(i-1)</span></li>
            <li>E: <span class="inline-code">a = F(i)</span>, <span class="inline-code">b = F(i-1)</span>
            </li>
          </ul>
        </section>

        <!-- ====================== Slide: Iterative Fibonacci commented ====================== -->
        <!-- <section data-auto-animate>
          <h2>Fibonacci lặp: chú thích ý nghĩa</h2>
          <pre><code class="language-python" data-trim data-line-numbers="">
def fibo_iter(n):
    if n == 0 or n == 1:
        return n
    else:
        a = 0
        b = 1          # a = F(0), b = F(1)
        for i in range(2, n+1):   # a = F(i-2), b = F(i-1)
            t = a
            a = b
            b = a + t   # a = F(i-1), b = F(i)
        # a = F(n-1), b = F(n)
        return b
          </code></pre>
          <p>Ưu điểm: loại bỏ mọi lời gọi lặp lại, chỉ dùng một vòng lặp.</p>
        </section> -->

        <!-- ====================== Slide: Recursion vs iteration summary ====================== -->
        <section>
          <h2>Đệ quy vs. lặp: Fibonacci &amp; giai thừa</h2>
          <ul>
            <li><span class="keyword">Giai thừa</span>:
              <ul>
                <li>Dễ cài bằng cả đệ quy <em>và</em> vòng lặp.</li>
              </ul>
            </li>
            <li><span class="keyword">Fibonacci</span>:
              <ul>
                <li>Dễ cài bằng đệ quy (giống định nghĩa).</li>
                <li>Khó hơn một chút bằng vòng lặp, nhưng chạy hiệu quả hơn.</li>
              </ul>
            </li>
            <li>Câu hỏi mở: <span class="keyword">khi nào</span> nhất thiết phải dùng đệ quy?</li>
          </ul>
        </section>
      </section>

      <!-- ====================== Chương 5: Đệ quy trên dữ liệu lồng nhau ====================== -->
      <section>
        <!-- ====================== Slide: Tiêu đề chương ====================== -->
        <section>
          <h1>
            <span class="text-light">5.</span><br />
            Đệ quy trên<br />dữ liệu lồng nhau
          </h1>
        </section>

        <!-- ====================== Slide: How to store an outline ====================== -->
        <section style="font-size: 0.9em;">
          <h2>Lưu một mục lục như thế nào?</h2>
          <div style="display: grid; grid-template-columns: auto auto; gap: 1em;">
            <div style="font-size: 0.5em;">
              <ul>
                <li>Preface</li>
                <li>1 Fundamentals
                  <ul>
                    <li>1.1 Basic Programming Model</li>
                    <li>1.2 Data Abstraction</li>
                    <li>1.3 Bags, Queues, and Stacks
                      <ul>
                        <li>Bags</li>
                        <li>Queues</li>
                        <li>Stacks</li>
                      </ul>
                    </li>
                    <li>1.4 Analysis of Algorithms</li>
                    <li>1.5 Case Study: Union-Find</li>
                  </ul>
                </li>
                <li>2 Sorting</li>
                <li>3 Searching</li>
                <li>…</li>
              </ul>
            </div>
            <div>
              <pre><code class="language-python" data-trim data-line-numbers="">
Book = [
    'Preface',
    '1 Fundamentals',
    ['1.1 Basic Programming Model',
     '1.2 Data Abstraction',
     '1.3 Bags, Queues, and Stacks',
     ['Bags',
      'Queues',
      'Stacks'],
     '1.4 Analysis of Algorithms',
     '1.5 Case Study: Union-Find'],
    '2 Sorting',
    '3 Searching',
    ...
]
          </code></pre>
            </div>
          </div>
          <ul>
            <li>Dùng <span class="keyword">list</span> lồng nhau để biểu diễn cấu trúc nhiều mức.</li>
            <li>Hỏi: in đề cương này ra màn hình như thế nào cho đẹp?</li>
          </ul>
        </section>

        <!-- ====================== Slide: print_outline_v1 ====================== -->
        <section data-auto-animate style="font-size: 0.9em;">
          <h2>Cách 1: in từng phần tử</h2>
          <pre><code class="language-python" data-trim data-line-numbers="">
# outline.py
def print_outline_v1(outline):
    for item in outline:
        print(item)
          </code></pre>
          <pre><code class="language-pycon" data-trim>
Preface
1 Fundamentals
['1.1 Basic Programming Model', '1.2 Data Abstraction',
 '1.3 Bags, Queues, and Stacks', ['Bags', 'Queues', 'Stacks'],
 '1.4 Analysis of Algorithms', '1.5 Case Study: Union-Find']
2 Sorting
3 Searching
          </code></pre>
          <p>Danh sách lồng bên trong bị in ra nguyên cả list &rarr; khó đọc.</p>
        </section>

        <!-- ====================== Slide: print_outline_v2 ====================== -->
        <section data-auto-animate style="font-size: 0.9em;">
          <h2>Cách 2: xử lý một mức lồng nhau</h2>
          <pre><code class="language-python" data-trim data-line-numbers="">
def print_outline_v2(outline):
    for item in outline:
        # handle nested lists
        if isinstance(item, list):
            for subitem in item:
                print(' ' * 4 + str(subitem))
        else:
            print(item)
          </code></pre>
          <pre><code class="language-pycon" data-trim>
Preface
1 Fundamentals
    1.1 Basic Programming Model
    1.2 Data Abstraction
    1.3 Bags, Queues, and Stacks
    ['Bags', 'Queues', 'Stacks']
    1.4 Analysis of Algorithms
    1.5 Case Study: Union-Find
2 Sorting
3 Searching
          </code></pre>
        </section>

        <!-- ====================== Slide: print_outline_v3 ====================== -->
        <section data-auto-animate style="font-size: 0.7em;">
          <h2>Cách 3: xử lý hai mức lồng nhau</h2>
          <pre><code class="language-python" data-trim data-line-numbers="">
def print_outline_v3(outline):
    for item in outline:
        # handle nested lists
        if isinstance(item, list):
            for subitem in item:
                # handle nested nested lists
                if isinstance(subitem, list):
                    for subsubitem in subitem:
                        print(' ' * 8 + str(subsubitem))
                else:
                    print(' ' * 4 + str(subitem))
        else:
            print(item)
          </code></pre>
          <pre><code class="language-pycon" data-trim>
Preface
1 Fundamentals
    1.1 Basic Programming Model
    1.2 Data Abstraction
    1.3 Bags, Queues, and Stacks
        Bags
        Queues
        Stacks
    1.4 Analysis of Algorithms
    1.5 Case Study: Union-Find
2 Sorting
3 Searching
          </code></pre>
        </section>

        <!-- ====================== Slide: For-loops do not suffice ====================== -->
        <section>
          <h2>Dùng for-loop là không đủ</h2>
          <ul>
            <li>Nếu outline có độ sâu lồng nhau là <span class="inline-code">N</span>:
              <ul>
                <li>Cần <span class="keyword">N</span> vòng lặp lồng nhau để xử lý.</li>
              </ul>
            </li>
            <li>Không thể viết sẵn chương trình cho “độ sâu bất kỳ”.</li>
            <li>Mã trở nên dài &amp; khó bảo trì ngay cả với độ sâu nhỏ (ví dụ 3).</li>
            <li>Giải pháp: dùng <span class="keyword">đệ quy</span> để tự xử lý mọi mức lồng nhau.</li>
          </ul>
        </section>

        <!-- ====================== Slide: print_outline_rec ====================== -->
        <section data-auto-animate>
          <h2>In outline bằng đệ quy</h2>
          <pre><code class="language-python" data-trim data-line-numbers="">
def indent(level):
    return ' ' * level


def print_outline_rec(outline, level):
    for item in outline:
        if isinstance(item, list):
            print_outline_rec(item, level+1)
        else:
            print(indent(level) + item)
          </code></pre>
          <ul>
            <li>Base case: phần tử là <span class="keyword">chuỗi</span> &rarr; in ra với thụt lề.</li>
            <li>Recursive case: phần tử là <span class="keyword">list</span> &rarr; gọi lại chính mình với
              <span class="inline-code">level+1</span>.
            </li>
          </ul>
        </section>

        <!-- ====================== Slide: print_outline_rec explanation ====================== -->
        <section data-auto-animate>
          <h2>Đệ quy giúp gì ở đây?</h2>
          <ul>
            <li>Cùng một đoạn mã xử lý được outline lồng sâu “vừa đủ” bất kỳ.</li>
            <li>Không cần thêm vòng lặp khi có thêm một mức lồng nhau.</li>
            <li>Ý tưởng: <span class="keyword">để chính hàm</span> xử lý phần sub-outline.</li>
            <li>Kết quả: mã gọn gàng, dễ hiểu, dễ mở rộng.</li>
          </ul>
        </section>

        <!-- ====================== Slide: Quiz outline calls ====================== -->
        <section style="font-size: 0.9em;">
          <h2>Quiz: số lần gọi đệ quy</h2>
          <pre><code class="language-python" data-trim data-line-numbers="">
outline = ['Intro',
           ['Part 1',
            ['Detail 1.1', 'Detail 1.2'],
            'Part 2'],
           'Conclusion']

print_outline_rec(outline, 0)
          </code></pre>
          <pre><code class="language-python" data-trim data-line-numbers="">
def print_outline_rec(outline, level):
    for item in outline:
        if isinstance(item, list):
            print_outline_rec(item, level+1)
        else:
            print(indent(level) + item)
          </code></pre>
          <p>Hỏi: tổng cộng <span class="keyword">bao nhiêu lần</span> hàm
            <span class="inline-code">print_outline_rec</span> được gọi (kể cả lần đầu)?
          </p>
          <ul>
            <li>A: 1 &nbsp;&nbsp; B: 2 &nbsp;&nbsp; C: 3 &nbsp;&nbsp; D: 6 &nbsp;&nbsp; E: 7
            </li>
          </ul>
        </section>

        <!-- ====================== Slide: Recursion vs iteration nested data ====================== -->
        <section>
          <h2>Đệ quy vs. lặp: dữ liệu lồng nhau</h2>
          <ul>
            <li>Với <span class="keyword">giai thừa</span>, <span class="keyword">Fibonacci</span>:
              <ul>
                <li>Đệ quy và vòng lặp đều làm được.</li>
              </ul>
            </li>
            <li>Với <span class="keyword">dữ liệu lồng nhau</span> độ sâu bất kỳ:
              <ul>
                <li>Không thể biết trước cần bao nhiêu vòng lặp.</li>
                <li><span class="keyword">Đệ quy là cần thiết</span> để xử lý mọi độ sâu.</li>
              </ul>
            </li>
          </ul>
        </section>
      </section>

      <!-- ====================== Chương 6: Mẫu lập trình đệ quy ====================== -->
      <section>
        <!-- ====================== Slide: Tiêu đề chương ====================== -->
        <section>
          <h1>
            <span class="text-light">6.</span><br />
            Mẫu lập trình<br />đệ quy
          </h1>
        </section>

        <!-- ====================== Slide: Review call frame analogy ====================== -->
        <section>
          <h2>Ôn lại: hình ảnh call stack</h2>
          <ul>
            <li>Mỗi lần hàm gọi chính nó &rarr; thêm một khung lên <span class="keyword">stack</span>.</li>
            <li>Base case: khung cuối cùng <span class="inline-code">return</span> kết quả.</li>
            <li>Các khung phía trên lần lượt nhận kết quả và <span class="keyword">kết hợp</span> lại.</li>
            <li>Hình dung này giúp kiểm tra:
              <ul>
                <li>Ta có tiến về base case không?</li>
                <li>Ta có kết hợp đúng kết quả con không?</li>
              </ul>
            </li>
          </ul>
        </section>

        <!-- ====================== Slide: Recursive programming pattern ====================== -->
        <section style="font-size: 0.8em;">
          <h2>Mẫu lập trình đệ quy</h2>
          <p><strong>Mục tiêu:</strong> giải bài toán <span class="keyword">P</span> trên một dữ liệu đầu vào.
          </p>
          <ul>
            <li><strong>Bước 1 – Phân rã dữ liệu</strong>:
              <ul>
                <li>Chia dữ liệu thành một hoặc nhiều phần nhỏ hơn.</li>
              </ul>
            </li>
            <li><strong>Bước 2 – Base case</strong>:
              <ul>
                <li>Nếu phần đủ nhỏ &rarr; trả lời trực tiếp.</li>
              </ul>
            </li>
            <li><strong>Bước 3 – Recursive case</strong>:
              <ul>
                <li>Nếu phần còn lớn &rarr; gọi đệ quy để giải <span class="keyword">P</span> trên phần
                  nhỏ hơn.</li>
                <li>Sau đó <span class="keyword">kết hợp</span> (recombine) kết quả để ra lời giải cuối.
                </li>
              </ul>
            </li>
          </ul>
          <p>Kỹ thuật này thường được gọi là <span class="keyword">“chia để trị”</span> (divide and conquer).
          </p>
        </section>

        <!-- ====================== Slide: Example outline pattern ====================== -->
        <section style="font-size: 0.9em;">
          <h2>Ví dụ mẫu đệ quy: Outline</h2>
          <p><strong>Mục tiêu:</strong> In mục lục từ list lồng nhau.</p>
          <ul>
            <li><strong>Phân rã</strong>: tách thành từng <span class="inline-code">item</span> trong list.
            </li>
            <li><strong>Base case</strong>:
              <ul>
                <li>Nếu <span class="keyword">string</span> &rarr; in ra với mức thụt lề hiện tại.</li>
              </ul>
            </li>
            <li><strong>Recursive case</strong>:
              <ul>
                <li>Nếu <span class="keyword">list</span> &rarr; gọi
                  <span class="inline-code">print_outline_rec</span> với <span class="inline-code">level+1</span>.
                </li>
              </ul>
            </li>
            <li><strong>Kết hợp</strong>: mọi dòng in ra trên màn hình ghép lại thành một outline hoàn
              chỉnh.</li>
          </ul>
        </section>

        <!-- ====================== Slide: Example Fibonacci pattern ====================== -->
        <section style="font-size: 0.9em;">
          <h2>Ví dụ mẫu đệ quy: Fibonacci</h2>
          <p><strong>Mục tiêu:</strong> Tính <span class="inline-code">F(n)</span>.</p>
          <ul>
            <li><strong>Phân rã</strong>: tách thành hai bài toán nhỏ hơn:
              <span class="inline-code">n-1</span> và <span class="inline-code">n-2</span>.
            </li>
            <li><strong>Base case</strong>:
              <ul>
                <li>Nếu <span class="inline-code">n</span> là 0 hoặc 1 &rarr; trả về <span class="inline-code">n</span>.
                </li>
              </ul>
            </li>
            <li><strong>Recursive case</strong>:
              <ul>
                <li>Nếu <span class="inline-code">n &gt;= 2</span>:
                  <span class="inline-code">F(n) = F(n-1) + F(n-2)</span>.
                </li>
              </ul>
            </li>
            <li><strong>Kết hợp</strong>: cộng hai kết quả con.</li>
          </ul>
        </section>

        <!-- ====================== Slide: Example factorial pattern ====================== -->
        <section style="font-size: 0.9em;">
          <h2>Ví dụ mẫu đệ quy: Giai thừa</h2>
          <p><strong>Mục tiêu:</strong> Tính <span class="inline-code">n!</span>.</p>
          <ul>
            <li><strong>Phân rã</strong>: biến dữ liệu <span class="inline-code">n</span> thành bài toán
              <span class="inline-code">n-1</span>.
            </li>
            <li><strong>Base case</strong>:
              <ul>
                <li>Nếu <span class="inline-code">n == 0</span> &rarr; trả về <span class="inline-code">1</span>.</li>
              </ul>
            </li>
            <li><strong>Recursive case</strong>:
              <ul>
                <li>Nếu <span class="inline-code">n &gt; 0</span>:
                  <span class="inline-code">n! = n * (n-1)!</span>.
                </li>
              </ul>
            </li>
            <li><strong>Kết hợp</strong>: nhân <span class="inline-code">n</span> với kết quả đệ quy.</li>
          </ul>
        </section>

        <!-- ====================== Slide: How to solve problems with recursion ====================== -->
        <section style="font-size: 0.8em;">
          <h2>Giải bài toán bằng đệ quy</h2>
          <ul>
            <li><span class="keyword">1. Quyết định cách phân rã dữ liệu</span>:
              <ul>
                <li>Dữ liệu lớn thành các phần nhỏ hơn ra sao?</li>
              </ul>
            </li>
            <li><span class="keyword">2. Xác định base case</span>:
              <ul>
                <li>Khi nào bài toán đủ đơn giản để trả lời trực tiếp?</li>
              </ul>
            </li>
            <li><span class="keyword">3. Thiết kế recursive case</span>:
              <ul>
                <li>Gọi lại hàm trên phần dữ liệu nhỏ hơn.</li>
                <li>Kết hợp kết quả để ra đáp án tổng thể.</li>
              </ul>
            </li>
          </ul>
          <p>Mỗi bước đều phải đảm bảo: <span class="keyword">tiến tới base case</span>, không được quay vòng
            vô hạn.</p>
        </section>
      </section>

      <!-- ====================== Footer ====================== -->
      <div class="footer">
        Tư duy Tính toán (HK 1 2025–2026) §11: Đệ quy
      </div>

    </div>
  </div>

  <script src="revealjs/dist/reveal.js"></script>
  <script src="plugin/notes/notes.js"></script>
  <script src="plugin/markdown/markdown.js"></script>
  <script src="plugin/highlight/highlight.js"></script>
  <script src="plugin/math/math.js"></script>
  <script>
    Reveal.initialize({
      controlsLayout: "edges",
      slideNumber: true,
      hashOneBasedIndex: true,
      hash: true,
      plugins: [RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX],
    });
  </script>

  <!-- Nguồn tham chiếu (ẩn trong HTML) -->
  <!-- :contentReference[oaicite:0]{index=0} -->
  <!-- :contentReference[oaicite:1]{index=1} -->
</body>

</html>